#! /bin/bash
# SPDX-License-Identifier: GPL-2.0
# Copyright (c) 2021 Western Digital Corporation.  All Rights Reserved.
#
# FS QA Test 237
#
# Test that zone autoreclaim works as expected, that is: if the dirty
# threshold is exceeded the data gets relocated to new block group and the
# old block group gets deleted. On block group deletion, the underlying device
# zone also needs to be reset.
#
. ./common/preamble
_begin_fstest auto quick zone balance

# Import common functions.
. ./common/filter

# real QA test starts here

_supported_fs btrfs
_require_scratch
_require_btrfs_command inspect-internal dump-tree
_require_btrfs_command filesystem sync
_require_command "$BLKZONE_PROG" blkzone
_require_zoned_device "$SCRATCH_DEV"

# This test requires specific data space usage, skip if we have compression
# enabled.
_require_no_compress

get_data_bg()
{
	$BTRFS_UTIL_PROG inspect-internal dump-tree -t CHUNK $SCRATCH_DEV |\
		grep -A 1 "CHUNK_ITEM" | grep -B 1 "type DATA" |\
		grep -Eo "CHUNK_ITEM [[:digit:]]+" | cut -d ' ' -f 2
}

get_data_bg_physical()
{
	# Assumes SINGLE data profile
	$BTRFS_UTIL_PROG inspect-internal dump-tree -t CHUNK $SCRATCH_DEV |\
		grep -A 4 CHUNK_ITEM | grep -A 3 'type DATA\|SINGLE' |\
	        grep -Eo 'offset [[:digit:]]+'| cut -d ' ' -f 2
}

_scratch_mkfs >/dev/null 2>&1
_scratch_mount -o commit=1 # 1s commit time to speed up test

uuid=$($BTRFS_UTIL_PROG filesystem show $SCRATCH_DEV |grep uuid: |\
        $AWK_PROG '{print $NF}')

if [[ "$uuid" == "" ]]; then
	echo "UUID for $SCRATCH_DEV is empty, this is not expected"
	exit 1
fi

fssize=$($BTRFS_UTIL_PROG fi usage -b $SCRATCH_MNT |grep "Device size" |\
	grep -Eo "[0-9]+")

allocated_fssize=$($BTRFS_UTIL_PROG fi usage -b $SCRATCH_MNT |grep "Device allocated" |\
	grep -Eo "[0-9]+")


start_data_bg_phy=$(get_data_bg_physical)
start_data_bg_phy=$((start_data_bg_phy >> 9))

zone_cap=$($BLKZONE_PROG report -o $start_data_bg_phy -l 1 $SCRATCH_DEV |\
	_filter_blkzone_report |\
	grep -Po "cap 0x[[:xdigit:]]+" | cut -d ' ' -f 2)
zone_cap=$((zone_cap << 9))

fs_reclaim_threshold=60
bg_reclaim_threshold=75
echo $fs_reclaim_threshold > /sys/fs/btrfs/"$uuid"/bg_reclaim_threshold
echo $bg_reclaim_threshold > /sys/fs/btrfs/"$uuid"/allocation/data/bg_reclaim_threshold

fs_fill_percent=$((fs_reclaim_threshold + 2))
fill_size=$((fssize * fs_fill_percent / 100))

# Remove the allocated size from the $fill_size
fill_size=$((fill_size - allocated_fssize))

bg_fill_percent=$((bg_reclaim_threshold + 2))
zone_fill_size=$((zone_cap * bg_fill_percent / 100))

# $fill_size might not cover the last zone block group with threshold
# for reclaim. Add the remaining bytes so that it can also be reclaimed
last_zone_offset=$((fill_size % zone_cap))

if [ $last_zone_offset -lt $zone_fill_size ]; then
	fill_size=$((fill_size + zone_fill_size - last_zone_offset))
fi

# This small file will be used to verify the relocation
relocate_file_size=$((zone_cap * 2 / 100))

# step 1, fill FS over $relocated_file_size and $fill_size
$XFS_IO_PROG -fc "pwrite 0 $relocate_file_size" $SCRATCH_MNT/$seq.test1 >> $seqres.full
$BTRFS_UTIL_PROG filesystem sync $SCRATCH_MNT

old_data_zone=$(get_data_bg)
old_data_zone=$((old_data_zone >> 9))
printf "Old data zone 0x%x\n" $old_data_zone >> $seqres.full

$XFS_IO_PROG -fc "pwrite 0 $fill_size" $SCRATCH_MNT/$seq.test2 >> $seqres.full
$BTRFS_UTIL_PROG filesystem sync $SCRATCH_MNT

open_zones_before_reclaim=$($BLKZONE_PROG report --offset $start_data_bg_phy $SCRATCH_DEV |\
	grep -v -e em -e nw | wc -l)

# sanity check
if [ $open_zones_before_reclaim -eq 0 ]; then
	echo "Error writing to the device"
fi

echo "Before reclaim: $open_zones_before_reclaim zones open" >> $seqres.full

# step 2, delete the $fill_size sized file to trigger reclaim
rm $SCRATCH_MNT/$seq.test2
$BTRFS_UTIL_PROG filesystem sync $SCRATCH_MNT
sleep 5 # sleep for transaction commit for 'rm' and for balance

# check that we don't have more zones open than before
open_zones_after_reclaim=$($BLKZONE_PROG report --offset $start_data_bg_phy $SCRATCH_DEV |\
	grep -v -e em -e nw | wc -l)
echo "After reclaim: $open_zones_after_reclaim zones open" >> $seqres.full

# Check that data was really relocated to a different zone
if [ $open_zones_after_reclaim != 1 ]; then
	echo "Error relocating the data"
fi

new_data_zone=$(get_data_bg)
new_data_zone=$((new_data_zone >> 9))
printf "New data zone 0x%x\n" $new_data_zone >> $seqres.full

# Check that data was really relocated to a different zone
if [ $old_data_zone -eq $new_data_zone ]; then
	echo "New zone same as old zone"
fi

# success, all done
echo "Silence is golden"
status=0
exit
